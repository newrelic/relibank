# ReliBank Frontend - Context for Claude

## Project Overview

This is a **demo banking application** built to showcase New Relic's observability capabilities. It's intentionally designed with specific behaviors to generate interesting telemetry data. This is NOT a production-ready banking app.

**Key Point**: Many "bugs" are actually intentional demo features. Always check the README before "fixing" things.

---

## Tech Stack

- **Framework**: React Router v7 in **SPA mode** (`ssr: false`)
- **UI**: Material-UI (MUI)
- **State**: React Context API (LoginContext for auth, PageContext for page data)
- **Build**: Vite
- **Language**: TypeScript
- **Deployment**: Kubernetes with Skaffold

---

## Project Structure

```
frontend_service/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ root.tsx                    # Root layout, LoginContext provider, auth logic
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login.tsx               # Login page (path: /)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard.tsx           # Main dashboard with accounts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ support.tsx             # Support/chatbot page
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings.tsx            # Settings page
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppLayout.tsx       # Main layout wrapper (Header + Sidebar + Footer)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Header.tsx          # Top bar with username + notifications
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Sidebar.tsx         # Left nav menu
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Footer.tsx          # Bottom disclaimer
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ dashboard/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ TransferCard.tsx    # Fund transfer component
‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ       ‚îî‚îÄ‚îÄ user.ts                 # TypeScript interfaces
‚îú‚îÄ‚îÄ react-router.config.ts          # IMPORTANT: ssr: false (SPA mode)
‚îî‚îÄ‚îÄ vite.config.ts                  # Proxy config for backend services
```

---

## Important: This is SPA Mode, Not SSR

**Configuration**: `react-router.config.ts` has `ssr: false`

This means:
- No server-side rendering
- No hydration issues (all rendering happens client-side)
- Build output only contains `build/client/` (no server bundle)
- Don't use SSR terminology in code or docs

---

## Authentication Flow

### Normal Flow:
1. User visits `/` (login page)
2. User logs in ‚Üí auth data saved to `sessionStorage`
3. `LoginContext` updates with `userData` (array of account objects)
4. Navigate to `/dashboard`

### State Management:
- **Location**: `app/root.tsx` in the `Layout` component
- **Context**: `LoginContext` provides:
  - `isAuthenticated: boolean`
  - `userData: UserAccount[] | null` (array of checking/savings accounts)
  - `handleLogin(data): void`
  - `handleLogout(): void`
  - `setUserData(data): void`
- **Persistence**: Syncs with `sessionStorage` automatically
- **Key Pattern**: State initializes to `null`, loads from sessionStorage in `useEffect`

### User Data Structure:
```typescript
userData = [
  { name: 'Alice Checking', account_type: 'checking', balance: 8500.25, routing_number: '123456789' },
  { name: 'Alice Savings', account_type: 'savings', balance: 4000.25, routing_number: '987654321' }
]
```

---

## üö® Demo-Specific Behaviors (DO NOT "FIX")

These are **intentional** for New Relic demos:

### 1. No Frontend Overdraft Validation
**Location**: `app/components/dashboard/TransferCard.tsx`

Users can transfer more than their balance. The frontend allows it, backend rejects it.

**Purpose**: Demonstrates backend validation errors and New Relic error telemetry.

**Don't**: Add `if (amount > balance) { showError(); return; }`

### 2. No Rollback on Transfer Errors
**Location**: `app/components/dashboard/TransferCard.tsx`

When a transfer fails:
- UI updates balances immediately (optimistic update)
- API fails ‚Üí error displays BUT balances stay incorrect
- No rollback to original state

**Purpose**: Visually shows impact of errors, makes errors more obvious in demos.

**Don't**: Add rollback logic like `setUserData(originalUserData)` in catch blocks.

### 3. Mock Data Fallback
**Location**: `app/routes/dashboard.tsx` (line 243)

```typescript
const userData = contextUserData || demoUserData;
```

Dashboard uses demo data if no auth exists. This is intentional for development.

### 4. Broken Theme Toggle Button
**Location**: `app/components/layout/Header.tsx`

A light/dark mode toggle button in the header that intentionally throws a JavaScript error when clicked.

**Purpose**: Demonstrates frontend error tracking, New Relic Browser error reporting, and client-side error handling.

**Behavior**:
- Button is visible in the header (sun/moon icon)
- Clicking it throws: `Error: Theme toggle is not implemented`
- Error is reported to New Relic Browser with context
- Shows impact of uncaught JavaScript errors on user experience

**Don't**: Implement actual theme switching unless explicitly updating demo scenarios.

### 5. Blocking Fibonacci Calculation in Support Chat
**Location**: `app/routes/support.tsx`

When users type phrases like "analyze my spending" or "spending analysis" in the support chat, it triggers a synchronous Fibonacci calculation on the main thread.

**Purpose**: Demonstrates frontend performance bottlenecks and blocking JavaScript that freezes the UI. Specifically designed to generate an **INP (Interaction to Next Paint) spike** in New Relic Browser monitoring.

**Behavior**:
- Triggers on spending analysis keywords (lines 54-63)
- Runs `calculateFibonacci(44)` synchronously (~8-13 seconds)
- Completely freezes the UI during calculation
- User's message doesn't appear until calculation completes
- Shows impact of blocking operations on user experience
- Creates a significant INP spike visible in New Relic Browser's Core Web Vitals

**Don't**: Move to web worker, make it async, or remove unless explicitly updating demo scenarios.

---

## Development

### Running the App

**Must run from parent directory**:
```bash
cd /path/to/relibank  # Parent directory!
skaffold dev
```

**NOT from**:
```bash
cd frontend_service  # Wrong! skaffold.yaml is in parent
```

The app runs at: `http://localhost:3000/`

### Debugging with kubectl

**Always use kubectl for debugging pods** - it's faster and more direct than parsing skaffold logs:

```bash
# Check pod status
kubectl get pods -n relibank | grep frontend

# View logs (last 30 lines)
kubectl logs -n relibank deployment/frontend-service --tail=30

# Follow logs in real-time
kubectl logs -n relibank deployment/frontend-service -f

# Check all pods
kubectl get pods -n relibank
```

When debugging issues after a rebuild, use `kubectl logs` to see what's happening in the pod directly instead of reading through skaffold output files.

### Backend Services

Vite proxies requests to Kubernetes services:
- `/accounts-service/*` ‚Üí accounts-service:5002
- `/chatbot-service/*` ‚Üí chatbot-service:5003
- `/bill-pay-service/*` ‚Üí bill-pay-service:5000
- `/transaction-service/*` ‚Üí transaction-service:5001

---

## Payments Functionality

### Payment Components

Located in `app/components/payments/`:

**PayBillCard.tsx** - One-time bill payments
- Unified payment method dropdown (bank accounts + credit cards)
- Supports both bank transfers (`/pay`) and card payments (`/card-payment`)
- Pre-filled form with test data
- IDs: `pay-bill-*` prefix

**RecurringPaymentsCard.tsx** - Recurring payment management
- Set up recurring payments with configurable frequency
- Cancel existing recurring payments
- Weekly/monthly/quarterly/annually options
- IDs: `recurring-payment-*` prefix

**PaymentMethodsCard.tsx** - Payment methods display
- Shows saved bank accounts (from LoginContext)
- Shows saved Stripe test cards
- Add new test cards (Visa/Mastercard/Amex)
- IDs: `payment-method-*` prefix

**RecentPaymentsCard.tsx** - Payment history
- Fetches real transactions from transaction-service
- Combines with mock data for demos
- Shows payment status with color-coded chips

### Bill Pay Endpoint Coverage

**‚úÖ All 6 user-facing endpoints are fully implemented:**

| Endpoint | Component | Function |
|----------|-----------|----------|
| `POST /bill-pay-service/pay` | PayBillCard | `handleBankPayment()` |
| `POST /bill-pay-service/card-payment` | PayBillCard | `handleCardPayment()` |
| `POST /bill-pay-service/recurring` | RecurringPaymentsCard | `handleAddRecurring()` |
| `POST /bill-pay-service/cancel/{bill_id}` | RecurringPaymentsCard | `handleCancelPayment()` |
| `POST /bill-pay-service/payment-method` | PaymentMethodsCard | `handleAddPaymentMethod()` |
| `GET /bill-pay-service/payment-methods/{customer_id}` | PaymentMethodsCard, PayBillCard | `fetchPaymentMethods()` |

**Internal endpoints (not in UI):**
- `/seed-demo-customers`, `/health` - Admin/health check endpoints

### Key Features

**Unified Payment Method Dropdown:**
- Single dropdown showing all payment options: `{Type} ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ {last4}`
- Examples: "Checking ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 6789", "Visa ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234"
- Automatically routes to bank transfer or card payment API based on selection

**Stripe Integration:**
- Uses Stripe test payment method tokens (pm_card_visa, pm_card_mastercard, pm_card_amex)
- No Stripe.js client-side integration required
- Hardcoded customer ID for Alice: `cus_TkCwwRJbjMVQZ4`

**Form Pre-filling:**
- All forms pre-filled with test values that map to real accounts in init.sql
- Payee: "Electric Company", Amount: "$125.50", Account: "67890" (Charlie's checking)

### Environment Variables

New Relic config (required):
```bash
VITE_NEW_RELIC_ACCOUNT_ID
VITE_NEW_RELIC_BROWSER_APPLICATION_ID
VITE_NEW_RELIC_LICENSE_KEY
```

### Development Optimizations

**Cache-Busting for Skaffold Rebuilds**

The app includes no-cache meta tags in `app/root.tsx` to prevent stale JS errors after Skaffold rebuilds:

```html
<meta httpEquiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta httpEquiv="Pragma" content="no-cache" />
<meta httpEquiv="Expires" content="0" />
```

**Why:** When Skaffold rebuilds the container, browsers may cache the old `index.html` which references old JS file hashes that no longer exist. This causes errors like "Failed to fetch module" or blank pages.

**Solution:** These headers force the browser to always fetch fresh HTML/JS files. While this adds a small performance overhead, it ensures smooth development. Can be safely removed if needed in the future.

**Vite Dependency Pre-optimization**

Icons used across different pages are pre-optimized in `vite.config.ts` to prevent page reloads on first navigation:

```typescript
optimizeDeps: {
  include: [
    '@mui/icons-material/Send',      // Support page
    '@mui/icons-material/Logout',    // Header
    '@mui/icons-material/Dashboard', // Dashboard page
    // ... other icons
  ]
}
```

**Why:** Without pre-optimization, navigating to a page for the first time triggers Vite to optimize its dependencies, causing a page reload. Pre-optimizing prevents this issue.

---

## Code Conventions

### ID Attributes for Synthetic Testing

**All clickable elements must have unique `id` attributes** for synthetic monitoring and automated testing.

**Naming Convention:** Use kebab-case in the format: `{component-area}-{element-purpose}-{element-type}`

**Examples by Element Type:**

**Buttons:**
- Pattern: `{area}-{action}-btn`
- Examples:
  - `pay-bill-submit-btn`
  - `recurring-payment-add-btn`
  - `dashboard-rewards-signup-btn`
  - `header-logout-btn`

**Text Inputs:**
- Pattern: `{area}-{field-name}`
- Examples:
  - `pay-bill-payee`
  - `transfer-amount`
  - `login-email`
  - `support-message-input`

**Select Dropdowns:**
- Pattern: `{area}-{field-name}-select`
- Examples:
  - `pay-bill-payment-method`
  - `transfer-from-account-select`
  - `recurring-payment-frequency`

**Navigation Links:**
- Pattern: `{area}-{destination}-link`
- Examples:
  - `sidebar-dashboard-link`
  - `sidebar-payments-link`
  - `login-signup-link`

**Icon Buttons:**
- Pattern: `{area}-{action}-btn`
- Examples:
  - `header-notifications-btn`
  - `header-theme-toggle-btn`
  - `login-toggle-password-btn`

**Component-Specific IDs:**

All components in `app/components/payments/` follow this convention:
- PayBillCard: `pay-bill-*`
- RecurringPaymentsCard: `recurring-payment-*`
- PaymentMethodsCard: `payment-method-*`

**Important:**
- NEVER change existing IDs - this breaks synthetic scripts
- ALWAYS add IDs to new clickable elements
- Use descriptive names that indicate the element's purpose
- Keep consistency within component areas

---

## Common Tasks

### Testing Error Scenarios

To test transfer failures for demos:
```bash
# Scale down bill-pay service
kubectl scale deployment bill-pay-service -n relibank --replicas=0

# Try transfer in UI ‚Üí will fail but balances stay incorrect

# Restore service
kubectl scale deployment bill-pay-service -n relibank --replicas=1
```

### Debugging Auth Issues

If user shows "Loading..." or username doesn't display:
1. Check console for `[Layout]` and `[Header]` logs
2. Check `sessionStorage.getItem('userData')` in browser console
3. Verify component is inside `<LoginContext.Provider>`
4. Check that `userData` is an array with account objects

### Getting Username

```typescript
// userData is an array of accounts
const userName = userData[0].name.split(' ')[0];  // "Alice" from "Alice Checking"
```

---

## Things to Avoid

### ‚ùå Don't Do:
1. **Enable SSR** - Keep `ssr: false` in config
2. **Add overdraft validation** - Intentionally missing for demos
3. **Add transfer rollback logic** - Intentionally missing for demos
4. **Remove mock data fallback** - Useful for development
5. **Run skaffold from frontend_service/** - Must run from parent directory
6. **Use SSR terminology** - This is SPA mode
7. **"Fix" demo behaviors** - They're intentional features
8. **Fix blocking Fibonacci in support chat** - Intentional performance demo

### ‚úÖ Do:
1. **Read the README** before making changes
2. **Check if "bugs" are intentional** (see Demo Behaviors section)
3. **Test with backend services running** (via skaffold)
4. **Keep state initialization in useEffect** (not during render)
5. **Sync state to sessionStorage** (use existing patterns)

---

## Page Layouts

### Login Page (`/`)
- Minimal layout (no sidebar/header)
- Just the login form centered on screen
- Uses separate theme from authenticated pages

### Authenticated Pages (`/dashboard`, `/support`, `/settings`)
- Full AppLayout with:
  - Left sidebar (navigation)
  - Top header (username + notifications + logout)
  - Main content area (route component)
  - Footer (disclaimer)

**Layout Decision Logic**: In `root.tsx`, based on `location.pathname === '/'`

### Dashboard Grid Layout Structure

The dashboard (`/dashboard`) uses a 12-column Material-UI Grid with the following layout:

**Hero Section (White Background)**
- Full-width white background section extending edge-to-edge
- Contains "Account Summary" title and balance cards
- Content has px: 48 horizontal padding to align with header and other content

**Grid Structure:**
1. **Row 1** (4-4-4): Three balance overview cards
   - Total Balance
   - Checking Account
   - Savings Account

2. **Row 2** (4-8): Transfer card + Line chart
   - Transfer Funds card (4 cols)
   - Spending over 6 months line chart (8 cols)

3. **Row 3** (6-6): Two charts side by side
   - Spending categories pie chart (6 cols)
   - Account balance trends stacked bar chart (6 cols)

4. **Row 4** (12): Full-width Recent Transactions table

**Consistent Padding:**
- Header: px: 48, py: 2
- Dashboard hero section content: px: 48
- Dashboard main content: px: 48, pb: 3
- Support page: px: 48, py: 3

---

## New Relic Integration

The app includes New Relic Browser agent:
- Script injected in `root.tsx` via `dangerouslySetInnerHTML`
- Config read from environment variables
- Template file: `app/nr.js`
- Placeholders replaced at build time by `generate_nrjs_file.sh`

Errors are automatically reported to New Relic (including transfer failures).

---

## Additional Notes

- **Material-UI Grid**: Uses `size` prop (not `xs`/`md` - newer MUI version)
- **Routing**: React Router v7 conventions (routes in `app/routes/`)
- **No Redux**: State management via Context API only
- **Docker**: Multi-stage build, runs on port 3000
- **Demo App**: Not production-ready, missing many security features

---

## When in Doubt

1. Check `README.md` for detailed architecture
2. Check demo behaviors section (don't "fix" intentional bugs)
3. Ask user before major changes to auth/state logic
4. Test in the actual Kubernetes environment (skaffold dev)
