# ReliBank Frontend - Context for Claude

## Project Overview

This is a **demo banking application** built to showcase New Relic's observability capabilities. It's intentionally designed with specific behaviors to generate interesting telemetry data. This is NOT a production-ready banking app.

**Key Point**: Many "bugs" are actually intentional demo features. Always check the README before "fixing" things.

---

## Tech Stack

- **Framework**: React Router v7 in **SPA mode** (`ssr: false`)
- **UI**: Material-UI (MUI)
- **State**: React Context API (LoginContext for auth, PageContext for page data)
- **Build**: Vite
- **Language**: TypeScript
- **Deployment**: Kubernetes with Skaffold

---

## Project Structure

```
frontend_service/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ root.tsx                    # Root layout, LoginContext provider, auth logic
‚îÇ   ‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ login.tsx               # Login page (path: /)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard.tsx           # Main dashboard with accounts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ support.tsx             # Support/chatbot page
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ payments.tsx            # Payments page
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ settings.tsx            # Settings page
‚îÇ   ‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppLayout.tsx       # Main layout wrapper (Header + Sidebar + Footer)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Header.tsx          # Top bar with username + notifications
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Sidebar.tsx         # Left nav menu
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Footer.tsx          # Bottom disclaimer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dashboard/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TransferCard.tsx    # Fund transfer component
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ payments/
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PayBillCard.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ RecurringPaymentsCard.tsx
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ PaymentMethodsCard.tsx
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ RecentPaymentsCard.tsx
‚îÇ   ‚îî‚îÄ‚îÄ types/
‚îÇ       ‚îî‚îÄ‚îÄ user.ts                 # TypeScript interfaces
‚îú‚îÄ‚îÄ public/
‚îÇ   ‚îî‚îÄ‚îÄ relibank.png                # Logo and static assets
‚îú‚îÄ‚îÄ react-router.config.ts          # IMPORTANT: ssr: false (SPA mode)
‚îî‚îÄ‚îÄ vite.config.ts                  # Proxy config for backend services
```

---

## üé® Theme & Branding

### Color Palette

ReliBank uses a **Green + Gold** color system based on the logo design, conveying trust, growth, and prosperity.

**Primary (Green) - Trust & Stability:**
- Forest Green: `#1a3d1a` - Main brand color (buttons, headers, active states)
- Sage Green: `#7a9b3e` - Accents, success states, chart data
- Deep Green: `#0f2610` - Dark accents and shadows

**Secondary (Lime) - Fresh & Modern:**
- Lime Accent: `#8db600` - Highlights and secondary actions
- Light Lime: `#a8cc3a` - Hover states and bright accents

**Tertiary (Gold) - Wealth & Premium:**
- Amber Gold: `#d97706` - Warnings, premium features, total balance displays
- Light Gold: `#fbbf24` - Call-to-action buttons, promotional highlights
- Deep Amber: `#b45309` - Dark gold accents

**Supporting Colors:**
- Charcoal: `#2d3748` - Primary text
- Gray: `#6b7280` - Secondary text
- Warm Gray: `#f8faf8` - Background
- White: `#ffffff` - Cards and paper surfaces
- Red: `#dc2626` - Error states

### Theme Configuration

Themes are defined in:
- `app/components/layout/AppLayout.tsx` - Main authenticated pages
- `app/routes/login.tsx` - Login page (same palette for consistency)

Both use MUI's `createTheme()` with the complete palette defined above.

### Static Assets

**Location**: `public/` directory

- `relibank.png` - Main logo (928x1232px, portrait)
  - Used in Sidebar (32x32px container)
  - Used in Login page (64x64px container)
  - Images preserve aspect ratio with `objectFit: 'contain'`

**Adding new assets**: Place files in `public/` and reference as `/filename.ext` in code.

---

## Important: This is SPA Mode, Not SSR

**Configuration**: `react-router.config.ts` has `ssr: false`

This means:
- No server-side rendering
- No hydration issues (all rendering happens client-side)
- Build output only contains `build/client/` (no server bundle)
- Don't use SSR terminology in code or docs

---

## Authentication Flow

### Normal Flow:
1. User visits `/` (login page)
2. User logs in ‚Üí auth data saved to `sessionStorage`
3. `LoginContext` updates with `userData` (array of account objects)
4. Navigate to `/dashboard`

### State Management:
- **Location**: `app/root.tsx` in the `Layout` component
- **Context**: `LoginContext` provides:
  - `isAuthenticated: boolean`
  - `userData: UserAccount[] | null` (array of checking/savings accounts)
  - `handleLogin(data): void`
  - `handleLogout(): void`
  - `setUserData(data): void`
- **Persistence**: Syncs with `sessionStorage` automatically
- **Key Pattern**: State initializes to `null`, loads from sessionStorage in `useEffect`

### User Data Structure:
```typescript
userData = [
  { name: 'Alice Checking', account_type: 'checking', balance: 8500.25, routing_number: '123456789' },
  { name: 'Alice Savings', account_type: 'savings', balance: 4000.25, routing_number: '987654321' }
]
```

---

## üö® Demo-Specific Behaviors (DO NOT "FIX")

These are **intentional** for New Relic demos:

### 1. No Frontend Overdraft Validation
**Location**: `app/components/dashboard/TransferCard.tsx`

Users can transfer more than their balance. The frontend allows it, backend rejects it.

**Purpose**: Demonstrates backend validation errors and New Relic error telemetry.

**Don't**: Add `if (amount > balance) { showError(); return; }`

### 2. Rollback on Transfer Errors
**Location**: `app/components/dashboard/TransferCard.tsx`

When a transfer fails:
- UI updates balances immediately (optimistic update)
- API fails ‚Üí balances and transactions are rolled back to original state
- Error displays with correct balances shown

**Implementation**: Original `userData` and `transactions` are stored before the optimistic update, then restored in the catch block on error.

**Note**: This demonstrates proper error handling and state management in React applications.

### 3. Default Transfer Amount
**Location**: `app/components/dashboard/TransferCard.tsx`

The transfer form pre-fills with $5.00 for quicker demo testing:
```typescript
const [amount, setAmount] = useState('5.00');  // Default value
```

After successful transfer, the amount resets to '5.00' (not empty) for convenience during repeated demos.

### 4. Mock Data Fallback
**Location**: `app/routes/dashboard.tsx` (line 243)

```typescript
const userData = contextUserData || demoUserData;
```

Dashboard uses demo data if no auth exists. This is intentional for development.

### 5. Broken Theme Toggle Button
**Location**: `app/components/layout/Header.tsx`

A light/dark mode toggle button in the header that intentionally throws a JavaScript error when clicked.

**Purpose**: Demonstrates frontend error tracking, New Relic Browser error reporting, and client-side error handling.

**Behavior**:
- Button is visible in the header (sun/moon icon)
- Clicking it throws: `Error: Theme toggle is not implemented`
- Error is reported to New Relic Browser with context
- Shows impact of uncaught JavaScript errors on user experience

**Don't**: Implement actual theme switching unless explicitly updating demo scenarios.

### 6. Blocking Fibonacci Calculation in Support Chat
**Location**: `app/routes/support.tsx`

When users type phrases like "analyze my spending" or "spending analysis" in the support chat, it triggers a synchronous Fibonacci calculation on the main thread.

**Purpose**: Demonstrates frontend performance bottlenecks and blocking JavaScript that freezes the UI. Specifically designed to generate an **INP (Interaction to Next Paint) spike** in New Relic Browser monitoring.

**Behavior**:
- Triggers on spending analysis keywords (lines 54-63)
- Runs `calculateFibonacci(44)` synchronously (~8-13 seconds)
- Completely freezes the UI during calculation
- User's message doesn't appear until calculation completes
- Shows impact of blocking operations on user experience
- Creates a significant INP spike visible in New Relic Browser's Core Web Vitals

**Don't**: Move to web worker, make it async, or remove unless explicitly updating demo scenarios.

---

## Development

### Running the App

**Must run from parent directory**:
```bash
cd /path/to/relibank  # Parent directory!
skaffold dev
```

**NOT from**:
```bash
cd frontend_service  # Wrong! skaffold.yaml is in parent
```

The app runs at: `http://localhost:3000/`

### Debugging with kubectl

**Always use kubectl for debugging pods** - it's faster and more direct than parsing skaffold logs:

```bash
# Check pod status
kubectl get pods -n relibank | grep frontend

# View logs (last 30 lines)
kubectl logs -n relibank deployment/frontend-service --tail=30

# Follow logs in real-time
kubectl logs -n relibank deployment/frontend-service -f

# Check all pods
kubectl get pods -n relibank
```

When debugging issues after a rebuild, use `kubectl logs` to see what's happening in the pod directly instead of reading through skaffold output files.

### Backend Services

Vite proxies requests to Kubernetes services:
- `/accounts-service/*` ‚Üí accounts-service:5002
- `/chatbot-service/*` ‚Üí chatbot-service:5003
- `/bill-pay-service/*` ‚Üí bill-pay-service:5000
- `/transaction-service/*` ‚Üí transaction-service:5001

---

## Responsive Design System

The application uses Material-UI's responsive breakpoints for mobile-first design:

**Breakpoint System:**
- `xs`: 0px+ (mobile)
- `sm`: 600px+ (tablet)
- `md`: 900px+ (small desktop)
- `lg`: 1200px+ (desktop)
- `xl`: 1536px+ (large desktop)

**Responsive Padding Pattern:**
All pages use consistent responsive horizontal padding:
```typescript
sx={{ px: { xs: 2, sm: 4, md: 8, lg: 16, xl: 32 } }}
```

**Grid Spacing:**
```typescript
<Grid container spacing={{ xs: 2, sm: 3, md: 4 }}>
```

**Responsive Typography:**
```typescript
sx={{ fontSize: { xs: '1.75rem', sm: '2rem', md: '2.125rem' } }}
```

**Stacking Behavior:**
- Dashboard overview cards: Stack on mobile (`xs: 12`), 3 columns on desktop (`md: 4`)
- Transfer + Chart: Stack on mobile (`xs: 12`), side-by-side on desktop (`lg: 4` / `lg: 8`)
- Payment cards: Stack on mobile (`xs: 12`), 2 columns on desktop (`lg: 6`)

**Height Management:**
Cards use responsive heights to ensure proper layout:
```typescript
sx={{ height: { xs: 'auto', lg: '500px' } }}
```

On mobile (`xs`), cards auto-size to their content. On desktop (`lg`), fixed heights with scrolling ensure consistent alignment.

---

## Payments Functionality

### Payment Components

Located in `app/components/payments/`:

**PayBillCard.tsx** - One-time bill payments
- Unified payment method dropdown (bank accounts + credit cards)
- Supports both bank transfers (`/pay`) and card payments (`/card-payment`)
- Pre-filled form with test data
- IDs: `pay-bill-*` prefix

**RecurringPaymentsCard.tsx** - Recurring payment management
- Set up recurring payments with configurable frequency
- Cancel existing recurring payments
- Weekly/monthly/quarterly/annually options
- IDs: `recurring-payment-*` prefix

**PaymentMethodsCard.tsx** - Payment methods display
- Shows saved bank accounts (from LoginContext)
- Shows saved Stripe test cards
- Add new test cards (Visa/Mastercard/Amex)
- Uses flexbox layout with vertical scrolling for long lists
- Matches height of PayBillCard on desktop (500px)
- IDs: `payment-method-*` prefix

**RecentPaymentsCard.tsx** - Payment history
- Fetches real transactions from transaction-service
- Combines with mock data for demos
- Shows payment status with color-coded chips
- Refreshes automatically when new payments are made

### Transaction Service Integration

**Recurring Payments Endpoint:**
- `GET /transaction-service/recurring-payments` - Fetches all recurring payment schedules from database
- Returns `RecurringScheduleRecord[]` with schedule details (ScheduleID, BillID, Amount, Frequency, etc.)
- RecurringPaymentsCard combines backend data with mock data for comprehensive demos
- Backend filters out cancelled schedules automatically
- Mock recurring payment IDs use string prefix ('mock-1', 'mock-2') to prevent key conflicts with database IDs

### Bill Pay Endpoint Coverage

**‚úÖ All 6 user-facing endpoints are fully implemented:**

| Endpoint | Component | Function |
|----------|-----------|----------|
| `POST /bill-pay-service/pay` | PayBillCard | `handleBankPayment()` |
| `POST /bill-pay-service/card-payment` | PayBillCard | `handleCardPayment()` |
| `POST /bill-pay-service/recurring` | RecurringPaymentsCard | `handleAddRecurring()` |
| `POST /bill-pay-service/cancel/{bill_id}` | RecurringPaymentsCard | `handleCancelPayment()` |
| `POST /bill-pay-service/payment-method` | PaymentMethodsCard | `handleAddPaymentMethod()` |
| `GET /bill-pay-service/payment-methods/{customer_id}` | PaymentMethodsCard, PayBillCard | `fetchPaymentMethods()` |

**Internal endpoints (not in UI):**
- `/seed-demo-customers`, `/health` - Admin/health check endpoints

### Key Features

**Unified Payment Method Dropdown (PayBillCard):**
- Single dropdown showing all payment options: `{Type} ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ {last4}`
- Examples: "Checking ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 6789", "Visa ‚Ä¢‚Ä¢‚Ä¢‚Ä¢ 1234"
- Automatically routes to bank transfer or card payment API based on selection
- Replaced separate payee text field and account dropdown for simpler UX

**Stripe Integration:**
- Uses Stripe test payment method tokens (pm_card_visa, pm_card_mastercard, pm_card_amex)
- No Stripe.js client-side integration required
- Hardcoded customer ID for Alice: `cus_TkCwwRJbjMVQZ4`

**Form Pre-filling:**
- All forms pre-filled with test values that map to real accounts in init.sql
- Payee: "Electric Company", Amount: "$125.50", Account: "67890" (Charlie's checking)

### Environment Variables

New Relic config (required):
```bash
VITE_NEW_RELIC_ACCOUNT_ID
VITE_NEW_RELIC_BROWSER_APPLICATION_ID
VITE_NEW_RELIC_LICENSE_KEY
```

### Development Optimizations

**Cache-Busting for Skaffold Rebuilds**

The app includes no-cache meta tags in `app/root.tsx` to prevent stale JS errors after Skaffold rebuilds:

```html
<meta httpEquiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
<meta httpEquiv="Pragma" content="no-cache" />
<meta httpEquiv="Expires" content="0" />
```

**Why:** When Skaffold rebuilds the container, browsers may cache the old `index.html` which references old JS file hashes that no longer exist. This causes errors like "Failed to fetch module" or blank pages.

**Solution:** These headers force the browser to always fetch fresh HTML/JS files. While this adds a small performance overhead, it ensures smooth development. Can be safely removed if needed in the future.

**Vite Dependency Pre-optimization**

Icons used across different pages are pre-optimized in `vite.config.ts` to prevent page reloads on first navigation:

```typescript
optimizeDeps: {
  include: [
    '@mui/icons-material/Send',      // Support page
    '@mui/icons-material/Logout',    // Header
    '@mui/icons-material/Dashboard', // Dashboard page
    // ... other icons
  ]
}
```

**Why:** Without pre-optimization, navigating to a page for the first time triggers Vite to optimize its dependencies, causing a page reload. Pre-optimizing prevents this issue.

---

## Code Conventions

### ID Attributes for Synthetic Testing

**All clickable elements must have unique `id` attributes** for synthetic monitoring and automated testing.

**Naming Convention:** Use kebab-case in the format: `{component-area}-{element-purpose}-{element-type}`

**Examples by Element Type:**

**Buttons:**
- Pattern: `{area}-{action}-btn`
- Examples:
  - `pay-bill-submit-btn`
  - `recurring-payment-add-btn`
  - `dashboard-rewards-signup-btn`
  - `header-logout-btn`

**Text Inputs:**
- Pattern: `{area}-{field-name}`
- Examples:
  - `pay-bill-payee`
  - `transfer-amount`
  - `login-email`
  - `support-message-input`

**Select Dropdowns:**
- Pattern: `{area}-{field-name}-select`
- Examples:
  - `pay-bill-payment-method`
  - `transfer-from-account-select`
  - `recurring-payment-frequency`

**Navigation Links:**
- Pattern: `{area}-{destination}-link`
- Examples:
  - `sidebar-dashboard-link`
  - `sidebar-payments-link`
  - `login-signup-link`

**Icon Buttons:**
- Pattern: `{area}-{action}-btn`
- Examples:
  - `header-notifications-btn`
  - `header-theme-toggle-btn`
  - `login-toggle-password-btn`

**Component-Specific IDs:**

All components in `app/components/payments/` follow this convention:
- PayBillCard: `pay-bill-*`
- RecurringPaymentsCard: `recurring-payment-*`
- PaymentMethodsCard: `payment-method-*`

**Important:**
- NEVER change existing IDs - this breaks synthetic scripts
- ALWAYS add IDs to new clickable elements
- Use descriptive names that indicate the element's purpose
- Keep consistency within component areas

---

## Common Tasks

### Testing Error Scenarios

To test transfer failures for demos:
```bash
# Scale down bill-pay service
kubectl scale deployment bill-pay-service -n relibank --replicas=0

# Try transfer in UI ‚Üí will fail but balances stay incorrect

# Restore service
kubectl scale deployment bill-pay-service -n relibank --replicas=1
```

### Debugging Auth Issues

If user shows "Loading..." or username doesn't display:
1. Check console for `[Layout]` and `[Header]` logs
2. Check `sessionStorage.getItem('userData')` in browser console
3. Verify component is inside `<LoginContext.Provider>`
4. Check that `userData` is an array with account objects

### Getting Username

```typescript
// userData is an array of accounts
const userName = userData[0].name.split(' ')[0];  // "Alice" from "Alice Checking"
```

---

## Things to Avoid

### ‚ùå Don't Do:
1. **Enable SSR** - Keep `ssr: false` in config
2. **Add overdraft validation** - Intentionally missing for demos
3. **Remove transfer rollback logic** - Demonstrates proper error handling
4. **Remove mock data fallback** - Useful for development
5. **Run skaffold from frontend_service/** - Must run from parent directory
6. **Use SSR terminology** - This is SPA mode
7. **"Fix" demo behaviors** - They're intentional features
8. **Fix blocking Fibonacci in support chat** - Intentional performance demo

### ‚úÖ Do:
1. **Read the README** before making changes
2. **Check if "bugs" are intentional** (see Demo Behaviors section)
3. **Test with backend services running** (via skaffold)
4. **Keep state initialization in useEffect** (not during render)
5. **Sync state to sessionStorage** (use existing patterns)

---

## Common Pitfalls & Best Practices

### 1. Responsive Grid Stacking - Avoid Awkward 2-1 Layouts

**Problem**: Using `size={{ xs: 12, sm: 6, md: 4 }}` creates an awkward layout on tablets where two cards appear in the first row and one card alone in the second row.

**Solution**: Skip the `sm` breakpoint entirely. Go directly from full-width mobile to 3-column desktop:

```typescript
// ‚ùå Wrong - creates 2-1 layout on tablets
<Grid item size={{ xs: 12, sm: 6, md: 4 }}>

// ‚úÖ Correct - stacks on mobile, 3 columns on desktop
<Grid item size={{ xs: 12, md: 4 }}>
```

**Result**: Cards either fully stack vertically (mobile) or display in proper 3-column grid (desktop). No awkward in-between states.

**Example**: Dashboard overview cards use this pattern (Total Balance, Checking, Savings).

---

### 2. Flexbox Scrolling - Height Constraints for Vertical Scroll

**Problem**: Adding `overflowY: 'auto'` to a child element doesn't create scrolling if the parent flexbox doesn't properly constrain height.

**Solution**: Both parent AND child need specific flexbox properties:

```typescript
// ‚úÖ Parent Card needs:
<Card sx={{
  display: 'flex',
  flexDirection: 'column',
  height: '100%'  // or fixed height like '500px'
}}>

// ‚úÖ Scrollable child needs:
<Box sx={{
  flexGrow: 1,       // Takes remaining space
  overflowY: 'auto', // Enables scrolling
  minHeight: 0       // Critical! Allows flex item to shrink below content size
}}>
```

**Why `minHeight: 0` is critical**: By default, flex items have `min-height: auto`, which prevents them from shrinking below their content size. Setting `minHeight: 0` overrides this and allows scrolling to work.

**Example**: PaymentMethodsCard uses this pattern to scroll long payment method lists while matching PayBillCard height.

---

### 3. Skaffold File Sync Limitations (Development)

**Problem**: When editing Python files in `transaction-service`, Skaffold's file sync mechanism sometimes fails. Changes aren't reflected in the running pod even after waiting.

**Symptoms**:
- Skaffold logs show: "sync failed for artifact" or "didn't sync any files"
- New endpoints return 404 errors
- Code changes don't appear in pod even after rollout restart

**Workaround**: Force a full rebuild by modifying the Dockerfile:

```bash
# Add a comment to Dockerfile
echo "# Rebuild trigger" >> transaction_service/Dockerfile

# Or remove it if already there
# This forces Skaffold to detect a change and rebuild
```

**Why this happens**: Skaffold's sync mechanism is optimized for fast iteration but can miss changes to certain file types or during certain rebuild scenarios. This is a known limitation of the development setup.

**When to use**: Only when you've made code changes but they're not appearing in the running service. Try `kubectl rollout restart` first before forcing a rebuild.

**Note**: This is specific to local development. Production builds always do full builds and don't rely on file sync.

---

### 4. Adding New API Endpoints - Documentation Checklist

**Important**: Whenever you add a new API endpoint during a session, you MUST update the following documentation:

**Required Updates:**

1. **Service README** (e.g., `transaction_service/README.md`)
   - Add endpoint to the API Endpoints table
   - Include method, path, description, and response format
   - Document any special behaviors (date conversion, filtering, etc.)

2. **Frontend .claude.md** (if frontend uses the endpoint)
   - Add to relevant integration section
   - Document how the frontend consumes the endpoint
   - Note any data transformations or filtering logic

3. **Frontend README.md** (if frontend uses the endpoint)
   - Update integration/endpoint coverage sections
   - Document component usage

4. **Postman Collection** (`postman/Relibank.postman_collection.json`)
   - Add new request to appropriate service folder
   - Include sample URL and any query parameters
   - Add description explaining what the endpoint does
   - Test the endpoint before committing

**Example Checklist:**
- [ ] Added endpoint to service README API table
- [ ] Updated frontend .claude.md (if applicable)
- [ ] Updated frontend README.md (if applicable)
- [ ] Added request to Postman collection
- [ ] Tested endpoint in Postman

**Why this matters**: Documentation gets stale quickly. Updating it immediately while the context is fresh ensures accuracy and saves time later. The Postman collection is especially important for API testing and demos.

---

## Page Layouts

### Login Page (`/`)
- Minimal layout (no sidebar/header)
- Just the login form centered on screen
- Uses separate theme from authenticated pages

### Authenticated Pages (`/dashboard`, `/support`, `/settings`)
- Full AppLayout with:
  - Left sidebar (navigation)
  - Top header (username + notifications + logout)
  - Main content area (route component)
  - Footer (disclaimer)

**Layout Decision Logic**: In `root.tsx`, based on `location.pathname === '/'`

### Dashboard Grid Layout Structure

The dashboard (`/dashboard`) uses a 12-column Material-UI Grid with the following layout:

**Hero Section (White Background)**
- Full-width white background section extending edge-to-edge
- Contains "Account Summary" title and balance cards
- Content has px: 48 horizontal padding to align with header and other content

**Grid Structure:**
1. **Row 1** (4-4-4): Three balance overview cards
   - Total Balance
   - Checking Account
   - Savings Account

2. **Row 2** (4-8): Transfer card + Line chart
   - Transfer Funds card (4 cols)
   - Spending over 6 months line chart (8 cols)

3. **Row 3** (6-6): Two charts side by side
   - Spending categories pie chart (6 cols)
   - Account balance trends stacked bar chart (6 cols)

4. **Row 4** (12): Full-width Recent Transactions table

**Consistent Padding:**
- Header: px: 48, py: 2
- Dashboard hero section content: px: 48
- Dashboard main content: px: 48, pb: 3
- Support page: px: 48, py: 3

---

## New Relic Integration

The app includes New Relic Browser agent:
- Script injected in `root.tsx` via `dangerouslySetInnerHTML`
- Config read from environment variables
- Template file: `app/nr.js`
- Placeholders replaced at build time by `generate_nrjs_file.sh`

Errors are automatically reported to New Relic (including transfer failures).

---

## Additional Notes

- **Material-UI Grid**: Uses `size` prop (not `xs`/`md` - newer MUI version)
- **Routing**: React Router v7 conventions (routes in `app/routes/`)
- **No Redux**: State management via Context API only
- **Docker**: Multi-stage build, runs on port 3000
- **Demo App**: Not production-ready, missing many security features

---

## When in Doubt

1. Check `README.md` for detailed architecture
2. Check demo behaviors section (don't "fix" intentional bugs)
3. Ask user before major changes to auth/state logic
4. Test in the actual Kubernetes environment (skaffold dev)
