"""
ReliBank Brute Force Attack Simulation - Charlie Account
This script simulates a brute force attack attempting to login to Charlie's account
with multiple incorrect passwords to generate FailedLoginInvalidPassword errors in New Relic
"""

import os
from selenium import webdriver
from selenium.webdriver.chrome.service import Service as ChromeService
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
from datetime import datetime

# Configuration
HEADLESS_MODE = True
# Use environment variable or default to localhost for local testing
# In GitHub Actions, set RELIBANK_BASE_URL to the appropriate URL
BASE_URL = os.getenv("RELIBANK_BASE_URL", "http://localhost:3000")
TARGET_EMAIL = "charlie.b@relibank.com"

# Simulated brute force password attempts - expanded rainbow table
PASSWORD_ATTEMPTS = [
    # Common passwords (20)
    'password123',
    'Password123!',
    'password',
    'Password1',
    'pass123',
    '123456789',
    '12345678',
    '1234567890',
    'qwerty123',
    'qwertyuiop',
    'abc123',
    'monkey123',
    'letmein123',
    'letmein',
    'welcome123',
    'welcome',
    'admin123',
    'admin',
    'administrator',
    'root',

    # Charlie-specific attempts (10)
    'charlie123',
    'Charlie123',
    'Charlie2024!',
    'charlie2024',
    'charlie@2024',
    'charlieb',
    'charlie.b',
    'charliebaker',
    'CharlieB2024',
    'charlie@relibank',

    # Bank-related attempts (6)
    'relibank123',
    'Relibank123',
    'relibank2024',
    'banking123',
    'bank123',
    'finance123',

    # Common patterns (8)
    'P@ssw0rd',
    'P@ssword123',
    'Password!',
    'Pass@word1',
    'Passw0rd!',
    'Summer2024',
    'Winter2024',
    'Spring2024',

    # Keyboard patterns (5)
    'qazwsx123',
    'qweasd123',
    'zxcvbnm123',
    'asdfgh123',
    'zaq1xsw2',

    # Dates and numbers (11)
    '01011990',
    '12345',
    '111111',
    '000000',
    '123123',
    '121212',
    '102030',
    '2024',
    '2023',
    '2025',
    'Fall2024'
]


def run_brute_force_attack():
    """
    Execute brute force attack simulation against Charlie's account
    Returns dict with results
    """
    start_time = datetime.now()
    results = {
        "status": "running",
        "target": TARGET_EMAIL,
        "total_attempts": len(PASSWORD_ATTEMPTS),
        "successful_attempts": 0,
        "failed_attempts": 0,
        "errors": [],
        "start_time": start_time.isoformat()
    }

    # Setup Chrome driver
    chrome_options = Options()
    if HEADLESS_MODE:
        chrome_options.add_argument("--headless=new")
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")

    chrome_options.add_argument("--window-size=1920,1080")

    try:
        # Auto-detect and setup ChromeDriver (works in both local and GitHub Actions)
        service = ChromeService(ChromeDriverManager().install())

        # Don't set binary_location - let it auto-detect Chrome/Chromium

        driver = webdriver.Chrome(service=service, options=chrome_options)
        wait = WebDriverWait(driver, 10)

        print(f"=== SIMULATED BRUTE FORCE ATTACK ON {TARGET_EMAIL} ===")
        print(f"Target: {TARGET_EMAIL}")
        print(f"Attempts: {len(PASSWORD_ATTEMPTS)}")
        print("")

        # Navigate to ReliBank login page once
        driver.get(BASE_URL)
        print("Navigated to login page")

        # Wait for React to fully render
        time.sleep(10)

        # Find and fill username field once (using NAME attribute since ID is dynamically generated by MUI Autocomplete)
        username_field = wait.until(EC.presence_of_element_located((By.NAME, "username")))
        # Click to focus, select all with Cmd+A (macOS) or Ctrl+A (Linux/Windows), then type to replace
        username_field.click()
        time.sleep(0.3)
        # Use platform-appropriate select-all command
        import platform
        if platform.system() == 'Darwin':  # macOS
            username_field.send_keys(Keys.COMMAND + "a")
        else:  # Linux/Windows
            username_field.send_keys(Keys.CONTROL + "a")
        time.sleep(0.2)
        # Type the target email (replaces selected text)
        username_field.send_keys(TARGET_EMAIL)
        time.sleep(0.5)
        print(f"Username set to: {TARGET_EMAIL}")
        print("")

        for attempt_number, password in enumerate(PASSWORD_ATTEMPTS, 1):
            try:
                print(f"--- Attempt {attempt_number}/{len(PASSWORD_ATTEMPTS)} ---")

                # Find and set password field using select-all + type (ensures React state updates)
                password_field = wait.until(EC.presence_of_element_located((By.ID, "password")))
                password_field.click()
                time.sleep(0.3)
                # Use platform-appropriate select-all command
                if platform.system() == 'Darwin':  # macOS
                    password_field.send_keys(Keys.COMMAND + "a")
                else:  # Linux/Windows
                    password_field.send_keys(Keys.CONTROL + "a")
                time.sleep(0.2)
                password_field.send_keys(password)
                time.sleep(0.3)
                print(f"Password attempt: {password}")

                # Click submit button
                submit_button = wait.until(EC.element_to_be_clickable((By.ID, "login-submit-btn")))
                submit_button.click()
                print("Submitted login attempt via form")

                # Wait for response
                time.sleep(3)

                # Check if login failed (still on login page, not on dashboard)
                current_url = driver.current_url
                if "dashboard" not in current_url:
                    results["failed_attempts"] += 1
                    print(f"✓ Attempt {attempt_number} failed as expected")
                else:
                    results["successful_attempts"] += 1
                    print(f"⚠ Attempt {attempt_number} succeeded (unexpected!)")

                # Delay between attempts to mimic realistic brute force attack timing
                print("Waiting 2.5 seconds before next attempt...")
                time.sleep(2.5)
                print("")

            except Exception as e:
                error_msg = f"Error on attempt {attempt_number}: {str(e)}"
                print(f"❌ {error_msg}")
                results["errors"].append(error_msg)
                results["failed_attempts"] += 1

        print("=== BRUTE FORCE ATTACK COMPLETE ===")
        print(f"Total failed attempts: {results['failed_attempts']}")
        print(f"Total successful attempts: {results['successful_attempts']}")

        # Final wait to ensure all telemetry is sent to New Relic
        print("Final wait of 5 seconds for all error telemetry to be sent to New Relic...")
        time.sleep(5)

        results["status"] = "completed"
        results["end_time"] = datetime.now().isoformat()
        results["duration_seconds"] = (datetime.now() - start_time).total_seconds()

    except Exception as e:
        error_msg = f"Fatal error during brute force attack: {str(e)}"
        print(f"❌ {error_msg}")
        results["status"] = "error"
        results["errors"].append(error_msg)
        results["end_time"] = datetime.now().isoformat()

    finally:
        try:
            driver.quit()
            print("Browser closed. Script finished.")
        except:
            pass

    return results


if __name__ == "__main__":
    # Allow running this script standalone for testing
    result = run_brute_force_attack()
    print("\n=== FINAL RESULTS ===")
    print(f"Status: {result['status']}")
    print(f"Failed attempts: {result['failed_attempts']}/{result['total_attempts']}")
    print(f"Duration: {result.get('duration_seconds', 0):.2f} seconds")
